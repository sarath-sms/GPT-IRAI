repo contains following folders:
1. server: backend inside server with node express mongoose.
2. apps: web folder inside app folder contains pwa vite react ts


üìÅ server/controllers/adminAuthController.js
--------------------------------------------
import Admin from "../models/Admin.js";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";

const generateToken = (id, role) =>
  jwt.sign({ id, role }, process.env.JWT_SECRET);

export const adminLogin = async (req, res) => {
  try {
    const { mobile, password } = req.body;

    const admin = await Admin.findOne({ mobile });
    if (!admin) return res.status(404).json({ msg: "Admin not found" });

    const isMatch = await bcrypt.compare(password, admin.password);
    if (!isMatch) return res.status(401).json({ msg: "Invalid credentials" });

    const token = generateToken(admin._id, "admin");

    res.status(200).json({
      msg: "Login successful",
      admin: {
        id: admin._id,
        name: admin.name,
        mobile: admin.mobile,
        role: admin.role,
        pincodes: admin.pincodes,
      },
      token,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ msg: "Server error", error: error.message });
  }
};



üìÅ server/controllers/adminController.js
----------------------------------------
import Order from "../models/Order.js";
import Driver from "../models/Driver.js";
import Admin from "../models/Admin.js";

// üîπ Admin assigns order(s) to a driver
export const assignOrdersByAdmin = async (req, res) => {
  try {
    const { driverId, orderIds } = req.body;

    const driver = await Driver.findById(driverId);
    if (!driver) return res.status(404).json({ msg: "Driver not found" });

    // Update order records
    await Order.updateMany(
      { _id: { $in: orderIds } },
      { status: "out-for-delivery", driver: driver._id }
    );

    // Add to driver's assignedOrders
    driver.assignedOrders.push(...orderIds);
    await driver.save();

    res.status(200).json({
      msg: "Orders successfully assigned to driver",
      driver,
    });
  } catch (error) {
    console.error("‚ùå assignOrdersByAdmin error:", error);
    res.status(500).json({ msg: "Server error", error: error.message });
  }
};


// üîπ Create Admin
export const createAdmin = async (req, res) => {
  try {
    const { name, mobile, password, email, aadhaar, pan, drivingLicence, pincodes } = req.body;

    const existing = await Admin.findOne({ mobile });
    if (existing) return res.status(400).json({ msg: "Admin already exists" });

    const admin = await Admin.create({
      name,
      mobile,
      password,
      email,
      aadhaar,
      pan,
      drivingLicence,
      pincodes,
    });

    res.status(201).json({ msg: "Admin created successfully", admin });
  } catch (err) {
    console.error("Error creating admin:", err);
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Get all admins
export const getAdmins = async (req, res) => {
  try {
    const admins = await Admin.find();
    res.status(200).json(admins);
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Update Admin
export const updateAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    const updated = await Admin.findByIdAndUpdate(id, updateData, { new: true });
    if (!updated) return res.status(404).json({ msg: "Admin not found" });

    res.status(200).json({ msg: "Admin updated successfully", updated });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Delete Admin
export const deleteAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const deleted = await Admin.findByIdAndDelete(id);
    if (!deleted) return res.status(404).json({ msg: "Admin not found" });

    res.status(200).json({ msg: "Admin deleted successfully" });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};


üìÅ server/controllers/driverAuthController.js
---------------------------------------------
import Driver from "../models/Driver.js";
import jwt from "jsonwebtoken";

const generateToken = (id) =>
  jwt.sign({ id, role: "driver" }, process.env.JWT_SECRET);

// Driver login
export const driverLogin = async (req, res) => {
  try {
    const { mobile, password } = req.body;

    const driver = await Driver.findOne({ mobile });
    if (!driver) return res.status(404).json({ msg: "Driver not found" });

    const match = await driver.matchPassword(password);
    if (!match) return res.status(401).json({ msg: "Invalid credentials" });

    const token = generateToken(driver._id);
    res.status(200).json({
      msg: "Login successful",
      driver: { id: driver._id, name: driver.name, mobile: driver.mobile },
      token,
    });
  } catch (error) {
    res.status(500).json({ msg: "Login error", error: error.message });
  }
};



üìÅ server/controllers/driverController.js
-----------------------------------------
import Driver from "../models/Driver.js";
import jwt from "jsonwebtoken";

const generateToken = (id) =>
  jwt.sign({ id, role: "driver" }, process.env.JWT_SECRET);

// üîπ Create Driver
export const createDriver = async (req, res) => {
  try {
    const { name, mobile, password, aadhaar, pan, drivingLicence, assignedPincodes } = req.body;

    const exists = await Driver.findOne({ mobile });
    if (exists) return res.status(400).json({ msg: "Driver already exists" });

    const driver = await Driver.create({
      name,
      mobile,
      password,
      aadhaar,
      pan,
      drivingLicence,
      assignedPincodes,
    });

    res.status(201).json({ msg: "Driver created successfully", driver });
  } catch (error) {
    res.status(500).json({ msg: "Error creating driver", error: error.message });
  }
};

// üîπ Get all drivers
export const getDrivers = async (req, res) => {
  try {
    const drivers = await Driver.find().sort({ createdAt: -1 });
    res.status(200).json({ msg: "Drivers fetched", count: drivers.length, drivers });
  } catch (error) {
    res.status(500).json({ msg: "Error fetching drivers", error: error.message });
  }
};

// üîπ Update driver details
export const updateDriver = async (req, res) => {
  try {
    const driver = await Driver.findByIdAndUpdate(req.params.id, req.body, { new: true });
    if (!driver) return res.status(404).json({ msg: "Driver not found" });
    res.status(200).json({ msg: "Driver updated", driver });
  } catch (error) {
    res.status(500).json({ msg: "Error updating driver", error: error.message });
  }
};

// üîπ Delete driver
export const deleteDriver = async (req, res) => {
  try {
    await Driver.findByIdAndDelete(req.params.id);
    res.status(200).json({ msg: "Driver deleted" });
  } catch (error) {
    res.status(500).json({ msg: "Error deleting driver", error: error.message });
  }
};

// üîπ Assign orders to driver
export const assignOrderToDriver = async (req, res) => {
  try {
    const { driverId, orderIds } = req.body;

    const driver = await Driver.findById(driverId);
    if (!driver) return res.status(404).json({ msg: "Driver not found" });

    driver.assignedOrders.push(...orderIds);
    await driver.save();

    res.status(200).json({ msg: "Orders assigned successfully", driver });
  } catch (error) {
    res.status(500).json({ msg: "Error assigning orders", error: error.message });
  }
};



üìÅ server/controllers/driverOrderController.js
----------------------------------------------
import Order from "../models/Order.js";
import Driver from "../models/Driver.js";

export const getAssignedOrders = async (req, res) => {
  try {
    const driver = await Driver.findById(req.user.id).populate({
      path: "assignedOrders",
      populate: { path: "user", select: "name mobile" },
    });
    res.status(200).json({ msg: "Assigned orders fetched", orders: driver.assignedOrders });
  } catch (error) {
    res.status(500).json({ msg: "Error fetching orders", error: error.message });
  }
};

export const driverUpdateOrderStatus = async (req, res) => {
  try {
    const { status } = req.body;
    const order = await Order.findByIdAndUpdate(
      req.params.id,
      { status },
      { new: true }
    );
    res.status(200).json({ msg: "Order status updated", order });
  } catch (error) {
    res.status(500).json({ msg: "Error updating status", error: error.message });
  }
};



üìÅ server/controllers/iraiController.js
---------------------------------------
import User from "../models/User.js";
import Shop from "../models/Shop.js";
import { sendOtp } from "../utils/sendOtp.js";
import jwt from "jsonwebtoken";

const generateOtp = () => Math.floor(1000 + Math.random() * 9000).toString();

const createSecretToken = (payload) =>
  jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: "7d" });

// üîπ POST /api/irai/entry ‚Äî Register or Login with OTP
export const checkMobNo = async (req, res) => {
  try {
    const { name, mobile, pincode } = req.body;

    if (!/^\d{10}$/.test(mobile)) {
      return res.status(400).json({ msg: "Invalid Mobile Number" });
    }

    const otp = generateOtp();
    const expiryTime = new Date(Date.now() + 10 * 60 * 1000); // 10 mins

    // üè™ find shop by pincode
    const shop = await Shop.findOne({ pincode });
    if (!shop) return res.status(404).json({ msg: "Service not available in your area" });
    if (!shop.isOpen) return res.status(403).json({ msg: "Shop temporarily closed" });

    // üë§ find or create user
    let user = await User.findOne({ mobile });
    if (user) {
      user.verify = { code: otp, expiryTime };
      if (!user.pincode) user.pincode = pincode;
      await user.save();
    } else {
      user = await User.create({
        name,
        mobile,
        pincode,
        role: "user",
        verify: { code: otp, expiryTime },
        shops: [shop._id],
      });
    }

    // üîó link user to shop.customers
    await Shop.updateOne({ _id: shop._id }, { $addToSet: { customers: user._id } });

    // üì≤ send OTP
    // const otpSent = await sendOtp(otp, mobile);
    // if (!otpSent) return res.status(500).json({ msg: "Failed to send OTP" });

    res.status(200).json({
      msg: "OTP sent successfully!",
      data: {
        otp,
        name: user.name,
        mobile: user.mobile,
        pincode: user.pincode,
        shop: { id: shop._id, name: shop.name },
      },
    });
  } catch (error) {
    console.error("‚ùå Error in checkMobNo:", error);
    res.status(500).json({ msg: "Server error", error: error.message });
  }
};

export const checkOtp = async (req, res) => {
    try {
      const { mobile, otp } = req.body;
      if (!mobile || !otp) return res.status(400).json({ msg: "Mobile and OTP are required" });
  
      const user = await User.findOne({ mobile });
      if (!user) return res.status(404).json({ msg: "User not found" });
  
      const { code, expiryTime } = user.verify || {};
      if (!code) return res.status(400).json({ msg: "OTP not generated" });
      if (new Date(expiryTime) < new Date()) return res.status(401).json({ msg: "OTP expired" });
      if (String(code) !== String(otp)) return res.status(401).json({ msg: "Invalid OTP" });
  
      // ‚úÖ clear OTP field
      user.verify = {};
      await user.save();
  
      // üè™ refetch shop info
      const shop = await Shop.findOne({ pincode: user.pincode });
  
      // üîê generate JWT with full payload
      const token = createSecretToken({
        id: user._id,
        mobile: user.mobile,
        role: user.role,
      });
  
      // üç™ send cookie
      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "none",
      });
  
      // ‚úÖ final response
      return res.status(200).json({
        msg: "OTP verified successfully",
        profile: {
          id: user._id,
          name: user.name,
          mobile: user.mobile,
          pincode: user.pincode,
          shop: shop ? { id: shop._id, name: shop.name } : null,
        },
        token,
      });
    } catch (error) {
      console.error("‚ùå Error in checkOtp:", error);
      res.status(500).json({ msg: "Server error", error: error.message });
    }
  };
  


üìÅ server/controllers/orderController.js
----------------------------------------
import Order from "../models/Order.js";
import User from "../models/User.js";
import Shop from "../models/Shop.js";
import Product from "../models/Product.js";

// üí∞ Helper: Calculate GST (5%)
const calcGst = (subtotal) => Math.round(subtotal * 0.05);

export const placeOrder = async (req, res) => {
  try {
    const {
      userId,
      products,
      address,
      deliverySlot,
      paymentId, // Razorpay or mock
    } = req.body;

    if (!userId || !products?.length || !deliverySlot) {
      return res.status(400).json({ msg: "Missing required fields" });
    }

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "User not found" });

    // üè™ Find shop by pincode
    const shop = await Shop.findOne({ pincode: user.pincode });

    // üßæ Calculate totals
    let subtotal = 0;
    const orderItems = [];

    for (const item of products) {
      const product = await Product.findById(item.id);

      if (!product) continue; // skip invalid product

      let unitPrice = 0;

      // Category 1 style (fish - with size & cut)
      if (product.priceOptions?.length > 0) {
        const sizePrice =
          product.priceOptions.find((opt) => opt.type === item.size)?.price || 0;
        const cutFee =
          product.cutTypes.find((cut) => cut.type === item.cutType)?.price || 0;
        unitPrice = sizePrice + cutFee;
      } else {
        // Category 2 style (meat - flat price)
        unitPrice = product.price;
      }

      const totalPrice = unitPrice * (item.qty || 1);
      subtotal += totalPrice;

      orderItems.push({
        product: product._id,
        name: product.name,
        category: product.category,
        image: product.image,
        size: item.size || "Default",
        cutType: item.cutType || "Standard",
        qty: item.qty || 1,
        unitPrice,
        totalPrice,
      });
    }

    const gst = calcGst(subtotal);
    const deliveryFee = 38;
    const total = subtotal + gst + deliveryFee;

    // üß† Create order document
    const newOrder = await Order.create({
      user: user._id,
      shop: shop?._id || null,
      pincode: user.pincode,
      items: orderItems,
      subtotal,
      gst,
      deliveryFee,
      total,
      deliverySlot,
      address,
      paymentId,
      status: paymentId ? "paid" : "pending",
    });

    // üîó Add order reference to user
    await User.updateOne(
      { _id: user._id },
      { $addToSet: { orders: newOrder._id } }
    );

    // üîó Add to shop analytics (optional)
    if (shop) {
      await Shop.updateOne(
        { _id: shop._id },
        { $addToSet: { orders: newOrder._id } }
      );
    }

    res.status(201).json({
      msg: "Order placed successfully!",
      order: newOrder,
    });
  } catch (error) {
    console.error("‚ùå placeOrder error:", error);
    res.status(500).json({ msg: "Server error", error: error.message });
  }
};


üìÅ server/controllers/productController.js
------------------------------------------
import Product from "../models/Product.js";

// üîπ Create Product
export const createProduct = async (req, res) => {
  try {
    const product = await Product.create(req.body);
    res.status(201).json({ msg: "Product created successfully", product });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Get Products (all or filtered)
export const getProducts = async (req, res) => {
  try {
    const { category, pincode } = req.query;
    const filter = {};
    if (category) filter.category = category;
    if (pincode) filter.pincode = pincode;
    const products = await Product.find(filter);
    res.status(200).json(products);
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Update Product
export const updateProduct = async (req, res) => {
  try {
    const updated = await Product.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
    });
    if (!updated) return res.status(404).json({ msg: "Product not found" });
    res.status(200).json({ msg: "Product updated", updated });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Delete Product
export const deleteProduct = async (req, res) => {
  try {
    const deleted = await Product.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ msg: "Product not found" });
    res.status(200).json({ msg: "Product deleted" });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};


üìÅ server/controllers/shopController.js
---------------------------------------
import Shop from "../models/Shop.js";
import Driver from "../models/Driver.js";

// üîπ Create Shop
export const createShop = async (req, res) => {
  try {
    const { pincode, name, description, openTime, closeTime } = req.body;

    // Check duplicate pincode
    const existing = await Shop.findOne({ pincode });
    if (existing) return res.status(400).json({ msg: "Shop with this pincode already exists" });

    const shop = await Shop.create({
      pincode,
      name,
      description,
      openTime,
      closeTime,
    });

    res.status(201).json({ msg: "Shop created successfully", shop });
  } catch (err) {
    console.error("‚ùå createShop error:", err);
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Get All Shops
export const getAllShops = async (req, res) => {
  try {
    const shops = await Shop.find().populate("admins drivers", "name mobile role");
    res.status(200).json(shops);
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Get Single Shop by ID
export const getShopById = async (req, res) => {
  try {
    const shop = await Shop.findById(req.params.id).populate("admins drivers", "name mobile role");
    if (!shop) return res.status(404).json({ msg: "Shop not found" });
    res.status(200).json(shop);
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Update Shop
export const updateShop = async (req, res) => {
  try {
    const updated = await Shop.findByIdAndUpdate(req.params.id, req.body, { new: true });
    if (!updated) return res.status(404).json({ msg: "Shop not found" });
    res.status(200).json({ msg: "Shop updated", updated });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Delete Shop
export const deleteShop = async (req, res) => {
  try {
    const deleted = await Shop.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ msg: "Shop not found" });
    res.status(200).json({ msg: "Shop deleted" });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Toggle Open / Close
export const toggleShopStatus = async (req, res) => {
  try {
    const shop = await Shop.findById(req.params.id);
    if (!shop) return res.status(404).json({ msg: "Shop not found" });

    shop.isOpen = !shop.isOpen;
    await shop.save();

    res.status(200).json({ msg: `Shop is now ${shop.isOpen ? "Open ‚úÖ" : "Closed üîí"}`, shop });
  } catch (err) {
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ Link existing drivers to a shop
export const linkDriversToShop = async (req, res) => {
  try {
    const { shopId, driverIds } = req.body;

    const shop = await Shop.findById(shopId);
    if (!shop) return res.status(404).json({ msg: "Shop not found" });

    // Link drivers to shop
    for (const driverId of driverIds) {
      const driver = await Driver.findById(driverId);
      if (driver) {
        if (!driver.assignedPincodes.includes(shop.pincode)) {
          driver.assignedPincodes.push(shop.pincode);
          await driver.save();
        }
      }
    }

    shop.drivers = [...new Set([...shop.drivers, ...driverIds])];
    await shop.save();

    res.status(200).json({ msg: "Drivers linked to shop", shop });
  } catch (error) {
    console.error("‚ùå linkDriversToShop error:", error);
    res.status(500).json({ msg: "Server error", error: error.message });
  }
};

// üîπ Link admins to a shop
export const linkAdminsToShop = async (req, res) => {
  try {
    const { shopId, adminIds } = req.body;
    const shop = await Shop.findById(shopId);
    if (!shop) return res.status(404).json({ msg: "Shop not found" });

    shop.admins = [...new Set([...shop.admins, ...adminIds])];
    await shop.save();

    res.status(200).json({ msg: "Admins linked to shop", shop });
  } catch (error) {
    console.error("‚ùå linkAdminsToShop error:", error);
    res.status(500).json({ msg: "Server error", error: error.message });
  }
};

üìÅ server/controllers/superAdminController.js
---------------------------------------------
import User from "../models/User.js";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";

// üîπ Helper ‚Äî Token generator
const generateToken = (id, role) =>
  jwt.sign({ id, role }, process.env.JWT_SECRET);

// üîπ POST /api/admin/create ‚Äî Create first super admin
export const createSuperAdmin = async (req, res) => {
    console.log("‚úÖwoo")
  try {
    const { name, mobile, password } = req.body;

    // Check if super admin already exists
    const existing = await User.findOne({ role: "superAdmin" });
    if (existing) return res.status(400).json({ msg: "Super admin already exists" });

    const user = await User.create({
      name,
      mobile,
      password,
      role: "superAdmin",
    });

    const token = generateToken(user._id, user.role);
    res.status(201).json({ msg: "Super admin created", user, token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};

// üîπ POST /api/admin/login ‚Äî Super admin login
export const superAdminLogin = async (req, res) => {
  try {
    const { mobile, password } = req.body;
    const user = await User.findOne({ mobile, role: "superAdmin" });

    if (!user) return res.status(404).json({ msg: "Super admin not found" });

    const isMatch = await user.matchPassword(password);
    if (!isMatch) return res.status(401).json({ msg: "Invalid credentials" });

    const token = generateToken(user._id, user.role);
    res.status(200).json({
      msg: "Login successful",
      user: { id: user._id, name: user.name, mobile: user.mobile },
      token,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: "Server error", error: err.message });
  }
};



üìÅ server/middleware/authMiddleware.js
--------------------------------------
import jwt from "jsonwebtoken";
import User from "../models/User.js";

export const protect = async (req, res, next) => {
  try {
    let token;

    // ‚úÖ Try to extract token from headers or cookies
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    } else if (req.cookies?.token) {
      token = req.cookies.token;
    }

    // üö´ No token found
    if (!token) {
      return res.status(401).json({ msg: "Not authorized, no token" });
    }

    // ‚úÖ Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // ‚úÖ Fetch user by ID from token
    const user = await User.findById(decoded.id).select("-password -verify");
    if (!user) {
      return res.status(404).json({ msg: "User not found" });
    }

    // üß† Attach user to request for downstream use
    req.user = user;
    next();
  } catch (error) {
    console.error("JWT protect error:", error);
    res.status(401).json({ msg: "Not authorized, invalid or expired token" });
  }
};


export const authorizeRoles = (...allowedRoles) => {
    return (req, res, next) => {
      if (!req.user || !allowedRoles.includes(req.user.role)) {
        return res.status(403).json({ msg: "Forbidden: Access denied" });
      }
      next();
    };
  };


üìÅ server/models/Admin.js
-------------------------
import mongoose from "mongoose";
import bcrypt from "bcryptjs";

const AdminSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    mobile: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    email: { type: String },
    aadhaar: { type: String },
    pan: { type: String },
    drivingLicence: { type: String },
    pincodes: [{ type: String }],
    role: { type: String, default: "admin" },
  },
  { timestamps: true }
);

// Hash password before saving
AdminSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Match password
AdminSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

export default mongoose.model("Admin", AdminSchema);


üìÅ server/models/Driver.js
--------------------------
import mongoose from "mongoose";
import bcrypt from "bcryptjs";

const DriverSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    mobile: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    role: { type: String, default: "driver" },
    aadhaar: String,
    pan: String,
    drivingLicence: String,

    assignedPincodes: [String],
    assignedOrders: [{ type: mongoose.Schema.Types.ObjectId, ref: "Order" }],

    isActive: { type: Boolean, default: true },
  },
  { timestamps: true }
);

// Hash password before save
DriverSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

DriverSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

export default mongoose.model("Driver", DriverSchema);


üìÅ server/models/Order.js
-------------------------
import mongoose from "mongoose";

// üîπ Individual ordered item
const OrderItemSchema = new mongoose.Schema(
  {
    product: { type: mongoose.Schema.Types.ObjectId, ref: "Product", required: true },
    name: String,
    category: String,
    image: String,

    // For both category styles
    size: { type: String }, // e.g. "Medium"
    cutType: { type: String }, // e.g. "Slice"
    netWeight: { type: String },

    // Pricing
    qty: { type: Number, default: 1 },
    unitPrice: { type: Number, required: true }, // actual price (after size/cut)
    totalPrice: { type: Number, required: true }, // qty * (unitPrice + cutFee)
  },
  { _id: false }
);

// üîπ Main order schema
const OrderSchema = new mongoose.Schema(
  {
    user: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
    shop: { type: mongoose.Schema.Types.ObjectId, ref: "Shop" }, // optional future link
    pincode: String,

    items: [OrderItemSchema],

    subtotal: { type: Number, required: true },
    gst: { type: Number, required: true }, // 5%
    deliveryFee: { type: Number, required: true, default: 38 },
    total: { type: Number, required: true },

    deliverySlot: { type: String, required: true }, // "5PM - 6PM"

    // Payment & tracking
    paymentId: { type: String }, // from Razorpay
    status: {
      type: String,
      enum: ["pending", "paid", "processing", "out-for-delivery", "delivered", "cancelled"],
      default: "pending",
    },

    // Delivery address snapshot (at order time)
    address: {
      houseId: String,
      addr1: String,
      addr2: String,
      geo: {
        lat: Number,
        long: Number,
      },
    },

    // Tracking
    driver: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // assigned driver
    admin: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // who managed it (optional)

    // Metadata
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now },
  },
  { timestamps: true }
);

export default mongoose.model("Order", OrderSchema);



üìÅ server/models/Product.js
---------------------------
import mongoose from "mongoose";

const PriceOptionSchema = new mongoose.Schema(
  {
    type: { type: String },
    price: { type: Number, required: true },
    available: { type: Boolean, default: true },
  },
  { _id: false }
);

const CutTypeSchema = new mongoose.Schema(
  {
    type: { type: String },
    price: { type: Number, default: 0 },
  },
  { _id: false }
);

const ProductSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    category: { type: String, required: true }, // fish, meat, poultry
    subCategory: String,
    description: { type: String, default: "" },
    image: String,
    available: { type: Boolean, default: true },

    // üí° Two pricing systems
    priceOptions: [PriceOptionSchema], // for fish-like products
    price: Number,                     // for fixed-price items
    netWeight: String,                 // for meat/poultry
    cutTypes: [CutTypeSchema],         // for fish/meat

    // üè™ Optional linkage (future-ready)
    shopId: { type: mongoose.Schema.Types.ObjectId, ref: "Shop", required: false },
    pincode: { type: String }, // for search/indexing
  },
  { timestamps: true }
);

export default mongoose.model("Product", ProductSchema);



üìÅ server/models/Shop.js
------------------------
import mongoose from "mongoose";

const ShopSchema = new mongoose.Schema(
    {
      // üîπ Basic Info
      pincode: { type: String, unique: true, required: true },
      name: { type: String, required: true },
      description: { type: String, default: "" },
  
      // üîπ Operational Control
      isOpen: { type: Boolean, default: true },
      openTime: { type: String, default: "06:00 AM" },
      closeTime: { type: String, default: "01:00 PM" },
  
      // üîπ Role Relationships
      admins: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }],  // many-to-many
      drivers: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }], // many
      customers: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }], // ‚úÖ added
  
      // üîπ Orders
      orders: [{ type: mongoose.Schema.Types.ObjectId, ref: "Order" }],
  
      // üîπ Timestamps
      createdAt: { type: Date, default: Date.now },
    },
    { timestamps: true }
  );
  
  export default mongoose.model("Shop", ShopSchema);
  


üìÅ server/models/User.js
------------------------
import mongoose from "mongoose";
import bcrypt from "bcryptjs";

const AddressSchema = new mongoose.Schema(
  { homeId: String, addr1: String, addr2: String },
  { _id: false }
);

const VerifySchema = new mongoose.Schema(
  {
    code: String,
    expiryTime: Date,
  },
  { _id: false }
);

const UserSchema = new mongoose.Schema(
  {
    name: String,
    mobile: { type: String, required: true, unique: true },
    password: String,
    role: {
      type: String,
      enum: ["superAdmin", "admin", "driver", "user"],
      default: "user",
    },
    pincode: String,
    verify: VerifySchema,
    address: AddressSchema,
    orders: [{ type: mongoose.Schema.Types.ObjectId, ref: "Order" }],
    assignedOrders: [{ type: mongoose.Schema.Types.ObjectId, ref: "Order" }],
  },
  { timestamps: true }
);

// üîê Encrypt password before save (only if modified)
UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// üîë Password verification method
UserSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

export default mongoose.model("User", UserSchema);



üìÅ server/routes/adminRoutes.js
-------------------------------
import express from "express";
import { assignOrdersByAdmin } from "../controllers/adminController.js";
import { toggleShopStatus } from "../controllers/shopController.js";
import { protect, authorizeRoles } from "../middleware/authMiddleware.js";
import { superAdminLogin } from "../controllers/superAdminController.js";

const router = express.Router();

router.post("/login", superAdminLogin);
router.post("/assign-orders", protect, authorizeRoles("admin"), assignOrdersByAdmin);
router.patch("/shop/:id/toggle", protect, authorizeRoles("admin"), toggleShopStatus);

export default router;



üìÅ server/routes/driverRoutes.js
--------------------------------
import express from "express";
import { driverLogin } from "../controllers/driverAuthController.js";
import { getAssignedOrders, driverUpdateOrderStatus } from "../controllers/driverOrderController.js";
import { protect, authorizeRoles } from "../middleware/authMiddleware.js";

const router = express.Router();

// üîπ Driver login (public)
router.post("/login", driverLogin);

// üîπ Assigned orders (protected)
router.get("/orders", protect, authorizeRoles("driver"), getAssignedOrders);
router.patch("/orders/:id/status", protect, authorizeRoles("driver"), driverUpdateOrderStatus);

export default router;



üìÅ server/routes/productRoutes.js
---------------------------------
import express from "express";
import {
  createProduct,
  getProducts,
  updateProduct,
  deleteProduct,
} from "../controllers/productController.js";
import { authorizeRoles, protect } from "../middleware/authMiddleware.js";

const router = express.Router();

// Protected routes (superAdmin only)
router.post("/", protect, authorizeRoles("superAdmin"), createProduct);
router.get("/", getProducts);
router.put("/:id", protect, authorizeRoles("superAdmin"), updateProduct);
router.delete("/:id", protect, authorizeRoles("superAdmin"), deleteProduct);

export default router;



üìÅ server/routes/shopRoutes.js
---------------------------------
import express from "express";
import {
  createShop,
  getAllShops,
  getShopById,
  updateShop,
  deleteShop,
  toggleShopStatus,
  linkDriversToShop,
  linkAdminsToShop,
} from "../controllers/shopController.js";
import { authorizeRoles, protect } from "../middleware/authMiddleware.js";

const router = express.Router();

// üß† All routes require Super Admin (protected)
router.post("/create", protect, authorizeRoles("superAdmin"), createShop);
router.get("/", protect, authorizeRoles("superAdmin"), getAllShops);
router.get("/:id", protect, authorizeRoles("superAdmin"), getShopById);
router.patch("/:id", protect, authorizeRoles("superAdmin"), updateShop);
router.delete("/:id", protect, authorizeRoles("superAdmin"), deleteShop);
router.patch("/:id/toggle", protect, authorizeRoles("superAdmin", "admin"), toggleShopStatus);

router.post("/link-drivers", protect, authorizeRoles("superAdmin"), linkDriversToShop);
router.post("/link-admins", protect, authorizeRoles("superAdmin"), linkAdminsToShop);
export default router;



üìÅ server/routes/superAdminRoutes.js
------------------------------------
import express from "express";
import {
  createSuperAdmin,
  superAdminLogin,
} from "../controllers/superAdminController.js";
import {
  createDriver,
  getDrivers,
  updateDriver,
  deleteDriver,
  assignOrderToDriver,
} from "../controllers/driverController.js";
import {
  createProduct,
  getProducts,
  updateProduct,
  deleteProduct,
} from "../controllers/productController.js";
import {
  createShop,
  getAllShops,
  getShopById,
  updateShop,
  deleteShop,
  toggleShopStatus,
  linkDriversToShop,
  linkAdminsToShop,
} from "../controllers/shopController.js";
import { protect, authorizeRoles } from "../middleware/authMiddleware.js";
import { createAdmin, deleteAdmin, getAdmins, updateAdmin } from "../controllers/adminController.js";

const router = express.Router();

// üîπ SuperAdmin Auth
router.post("/create", createSuperAdmin);
router.post("/login", superAdminLogin);

// üîπ Admin Management
router.post("/admins", protect, authorizeRoles("superAdmin"), createAdmin);
router.get("/admins", protect, authorizeRoles("superAdmin"), getAdmins);
router.patch("/admins/:id", protect, authorizeRoles("superAdmin"), updateAdmin);
router.delete("/admins/:id", protect, authorizeRoles("superAdmin"), deleteAdmin);

// üîπ Driver Management
router.post("/drivers", protect, authorizeRoles("superAdmin"), createDriver);
router.get("/drivers", protect, authorizeRoles("superAdmin"), getDrivers);
router.patch("/drivers/:id", protect, authorizeRoles("superAdmin"), updateDriver);
router.delete("/drivers/:id", protect, authorizeRoles("superAdmin"), deleteDriver);
router.post("/drivers/assign-orders", protect, authorizeRoles("superAdmin"), assignOrderToDriver);

// üîπ Product Management
router.post("/products", protect, authorizeRoles("superAdmin"), createProduct);
router.get("/products", getProducts);
router.put("/products/:id", protect, authorizeRoles("superAdmin"), updateProduct);
router.delete("/products/:id", protect, authorizeRoles("superAdmin"), deleteProduct);

// üîπ Shop Management
router.post("/shops", protect, authorizeRoles("superAdmin"), createShop);
router.get("/shops", protect, authorizeRoles("superAdmin"), getAllShops);
router.get("/shops/:id", protect, authorizeRoles("superAdmin"), getShopById);
router.patch("/shops/:id", protect, authorizeRoles("superAdmin"), updateShop);
router.delete("/shops/:id", protect, authorizeRoles("superAdmin"), deleteShop);
router.patch("/shops/:id/toggle", protect, authorizeRoles("superAdmin"), toggleShopStatus);

// üîπ Linking
router.post("/shops/link-drivers", protect, authorizeRoles("superAdmin"), linkDriversToShop);
router.post("/shops/link-admins", protect, authorizeRoles("superAdmin"), linkAdminsToShop);

export default router;



üìÅ server/routes/userRoutes.js
------------------------------
import express from "express";
import { checkMobNo, checkOtp } from "../controllers/iraiController.js";
import { placeOrder } from "../controllers/orderController.js";
import { protect, authorizeRoles } from "../middleware/authMiddleware.js";
import { getProducts } from "../controllers/productController.js";

const router = express.Router();

// üîπ OTP-based auth (no token)
router.post("/entry", checkMobNo);
router.post("/verify", checkOtp);


// üîπ Orders (protected)
// TODO: Note: product search filter based on category or product name!
router.post("/order", protect, authorizeRoles("user"), placeOrder);

export default router;



üìÅ server/utils/sendOtp.js
--------------------------
import axios from "axios";

export const sendOtp = async (otp, mobile) => {
    try {
        const apiUrl = `https://restapi.smscountry.com/v0.1/Accounts/${process?.env?.SMSCOUNTRY_API_KEY}/SMSes/`;
        const payload = {
            Text: `Hey foodie! Your IRAITCHI OTP is ${otp}. Valid for 10 mins. Taste freshness‚Äîseafood & meat direct from market! @iraitchi.com`,
            Number: `91${mobile}`, // ensure it's in correct format
            SenderId: "IRAITI",
            DRNotifyUrl: "https://www.iraitchi.com/verifyOtp",
            DRNotifyHttpMethod: "POST",
            Tool: "API",
          }
        const response = await axios.post(apiUrl, payload, {
            auth: {
              username: process?.env?.SMSCOUNTRY_API_KEY,
              password: process?.env?.SMSCOUNTRY_TOKEN,
            },
            headers: {
              "Content-Type": "application/json",
            },
          });
          return response.data;
    } catch (error) {
        console.error("Error sending OTP:", error);
        return false;
    }
};


üìÅ server/server.js
-------------------
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import mongoose from "mongoose";

// ‚úÖ Import Role-Based Routes
import superAdminRoutes from "./routes/superAdminRoutes.js";
import adminRoutes from "./routes/adminRoutes.js";
import userRoutes from "./routes/userRoutes.js";
import driverRoutes from "./routes/driverRoutes.js";

// ‚úÖ Import Common Routes (Optional)
import productRoutes from "./routes/productRoutes.js";
import shopRoutes from "./routes/shopRoutes.js";

// TODO: remove before production
import { swaggerDocs } from "./swagger.js";

// ‚úÖ Environment Setup
dotenv.config();

// ‚úÖ Initialize App
const app = express();

// ‚úÖ Middleware Setup
app.use(
  cors({
    origin: [
      "http://localhost:5173",
      "http://127.0.0.1:5173",
      "http://localhost:3000",
      "http://127.0.0.1:3000",
    ],
    credentials: true,
  })
);
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ‚úÖ Base Health Check
app.get("/", (req, res) => {
  res.send("üî• IRAITCHI API IS RUNNING SMOOTHLY üî•");
});

// ‚úÖ Role-based Routes
app.use("/api/superadmin", superAdminRoutes);
app.use("/api/admin", adminRoutes);
app.use("/api/user", userRoutes);
app.use("/api/driver", driverRoutes);

// ‚úÖ Shared Modules
app.use("/api/products", productRoutes);
app.use("/api/shops", shopRoutes);
// TODO: remove before production
swaggerDocs(app);

// ‚úÖ MongoDB Connection
mongoose
  .connect(process.env.MONGO_URI)
  .then(() => console.log("‚úÖ MongoDB connected successfully"))
  .catch((err) => console.error("‚ùå MongoDB connection error:", err.message));

// ‚úÖ Server Start
const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log(`üöÄ Server running on http://localhost:${PORT}`));



üìÅ server/package.json
----------------------
{
  "name": "server",
  "version": "1.0.0",
  "description": "iraitchi server",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.20.0",
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.19.3"
  },
  "devDependencies": {
    "nodemon": "^3.1.10",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1"
  }
}











